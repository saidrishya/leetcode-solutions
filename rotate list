/*
Given a linked list, rotate the list to the right by k places, where k is non-negative.

Example 1:

Input: 1->2->3->4->5->NULL, k = 2
Output: 4->5->1->2->3->NULL
Explanation:
rotate 1 steps to the right: 5->1->2->3->4->NULL
rotate 2 steps to the right: 4->5->1->2->3->NULL
Example 2:

Input: 0->1->2->NULL, k = 4
Output: 2->0->1->NULL
Explanation:
rotate 1 steps to the right: 2->0->1->NULL
rotate 2 steps to the right: 1->2->0->NULL
rotate 3 steps to the right: 0->1->2->NULL
rotate 4 steps to the right: 2->0->1->NULL
*/

class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
       if(head == NULL || k==0) return head; 
       int n = len(head) ,d;
       if(k < n) d=k;
       else d = k%n;
        while(d--){
            head = rotate(head);
        }
return head;       
        
    }
    
    
    int len(ListNode *h){
        int c=0;
        while(h){
            c++;
            h=h->next;
        }
    return c;
    }
    
    ListNode *rotate(ListNode *head){
        ListNode *t = head;
        while(t->next->next != NULL) t=t->next;
        ListNode *x=t->next;
        t->next=NULL;
        x->next=head;
        head=x;
    return head;
        }
};
